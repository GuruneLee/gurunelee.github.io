---
tags:
  - 회고
at: 2024-08-20 22:34
created: 2024-08-19 23:31
updated: 2025-03-31 13:25
gh-page: true
---
# TL; DR,

---
  7월은 3분기가 새롭게 시작하는 달로, 새로운 일감을 받았다. 1,2 분기와는 다르게 영향범위가 큰 일감이 많아서 잘 해낼 수 있을까 걱정이 됐다. 두려움이 컸지만, 드디어 Backend 개발자로서 역량을 키울 수 있는 기회가 왔다는 생각이 들었다. 
  여러모로 스스로의 능력에대해 실망한게 많은 지난 분기여서, 이 기회를 더 확실히 잡아야겠다는 생각이 들었다. 
  이와 더불어, 내가 백엔드 개발을 본격적으로 시작한건 이번년도 1분기 부터였으니 아직 백엔드는 1년차 라는 생각을 가지고 **남들과 비교하지 말고** 차근차근, 꾸준히(!) 할 수 있는것 부터 쌓아나가자고 생각하고 있음을 남긴다.
# 7월의 액션 아이템
3Q에 20여개의 액션 아이템이 선정되었으나, 7월엔 그 중 가장 영향범위가 큰 아이템부터 진행하고자 두 가지 부터 진행하게 되었다.
- Long term conversation 동작 제어
- 신규 메뉴 추가

## Long term converesation 동작 제어 (LTC)
두 개의 탭을 동시에 띄워 오랜 시간 간격 하에 차례대로 상태를 업데이트 할 때, 두 번째 탭에서 수행한 결과가 첫 번째 탭에서 수행한 결과를 덮어씌우거나, 권한이 없는 동작을 수행하는 등 이상 동작을 하는 경우가 발생한 문제가 있었다.
![[Pasted image 20240820230403.png|두 사용자가 같은 데이터 조회 후 시간 간격을 두고 업데이트를 요청함 ([spring-data-jpa-환경에서-낙관적-락-optimistic-lock-을-사용한-동시성-문제-해결-second-lost-update-problem](https://medium.com/@taesulee93/spring-data-jpa-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD-optimistic-lock-%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-second-lost-update-problem-b64cfdf5982b) 발췌)]]

문제가 발생하는 e-sign 기능은 sign 1, sign 2 이렇게 단계별로 진행돼고, 각 단계별로 필요한 권한이 있다. 
권한 검증을 API 에서 진행하지 않고 Webapp 에서 처리하는 솔루션 구조 상 'sign1 권한이 있는 Client1' 과 'sign1 권한이 있는 Client2' 가 첫 조회 시 Sign 할 수 있는 권한이 있는 상태로 페이지가 열리게 되고, 각자 sign 버튼을 누르게 되면 Client2 가 sign2 를 진행하게 되는 문제다.

처음엔 Webapp 에 페이지의 마지막 업데이트 시간을 제공하고, update 시 DB 업데이트 시간과 비교하여 Webapp 에서 요청한 시간이 DB 저장 이전 시간이라면 예외를 뱉도록 구현하려고 했다. 그러나 [[optimistic lock]] 을 사용하면 LTC 뿐 아니라 실시간 동시성 제어를 해보자는 태수님의 조언을 듣고, JPA에서 제공하는 @Version 기능을 사용해보기로 하였다 ([[JPA Optimistic lock - LockModeType]]).
아직 해당 데이터의 도메인구조에 익숙하지 않아 직접 비슷한 구조를 만들어보고, 테스트 코드를 작성해 PoC 하는 과정을 거쳤다. - [github mr](https://github.com/GuruneLee/opt-lock-poc)감사하게도 태수님이 poc 소스코드를 리뷰해주시기도 하고, 실제 이슈에도 리뷰를 잘 남겨주셔서 무사히 일감을 마칠 수 있었다.

새로운 개념을 솔루션에 도입하기 위해선 많은 검증이 필요하다. 이를 직접 소스코드를 통해 검증하는 과정이 정말 즐거웠고, 복잡한 비즈니스 로직에 직접 적용하기 전 테스트의 중요성도 깨닫게 되었다. 또, 이 이슈를 해결하며 [[cubeCTMS MVR 관련 LocalDateTime 응답 포맷이 다른 이유 - SS, SSF3]], [[Spring boot 요청,응답 변환]] 등 새롭게 알게된 내용을 정리할 수 있었다.

## 신규 메뉴 추가
솔루션의 핵심 비즈니스로직을 관통하는 메뉴를 동적으로 추가, 삭제 하고 메뉴 라벨을 수정할 수 있게하는 일감을 받아 이번분기에 진행하게 되었다. 솔루션의 중심 기능이다보니 광범위한 영향범위를 모두 수용할 수 있으며, 정적으로 다뤄왔던 메뉴를 동적으로 기능할 수 있게 하기위한 구조? 방법? 해법? 을 생각해내고 결정하는것이 가장 힘들었다.

아니? 일감을 받아서 살펴보면서, **영향이 가는 API 들을 리스팅 해보지 않고 그냥 어렴풋이 머릿속으로 여기여기 영향이 있는것 같다고 생각했고, 메뉴 시스템을 정교하게 설계하고 적용하면 모든 관련 기능을 한 큐에 커버할 수 있을 것이라 생각한 것이 나를 가장 힘들게 했던것 같다**. `은탄환은 없다` 라는 말이 있다. 소프트웨어 개발의 복잡성을 한번에 해소할 마법같은 솔루션(은탄환)은 없다는 말인데, 난 이 일감을 단 한 발로 해결할 수 있는 획기적인 구조가 있다고 믿고 찾기위해 시간을 오래 투자했다.

결론적으론, '완전히 동적이며, 모든 영향범위에 단일 모듈로 적용되는 완벽한 구조' 는 포기하고 솔루션의 다른 도메인에서 사용하고 있던 구조를 찾아와서 비슷하게 적용하였다. 그 과정에서 영향범위에 있는 기능을 BackLog 로 정리하여 한땀한땀 수정해 나가기로 했다 ([[MvrType 추가 BACK_LOG]]).
![[Pasted image 20240822005853.png|메뉴 추가 Backlog 일부|400]]

앞서 이상적인 구조를 생각해 낸다며 날려보낸 시간 덕에 이 이슈는 8월의 아이템으로 이월되었다. 
그러나, 큰 이슈를 맡으며 **은탄환이 있을것이라 맹목적으로 믿고 시간을 낭비하는 행동은 하지 말아야겠다**는 생각을 가지게 되었다.

아무튼, 7월엔 신규메뉴추가에 대한 [[PM5419 신규 MVR type 추가|영향도 분석과 설계에 시간]]을 소진하고 말았다. 생각보다 시간을 많이 써서 아쉬웠지만 솔루션의 구조, 특히 메뉴와 권한 관계 / 각 영역의 테이블 구조, 를 자세히 파악하고 익힐 수 있었다. 8월에 실제 구현을진행하기 전, 파악한 구조를 문서화해서 공유해보자.

# 8월의 액션 아이템
8월엔 7월에 못다한 *신규메뉴추가* 아이템을 구현하고, 더불어 파악된 구조를 문서화하고자 한다.
더불어, 전체 SP가 20 이 넘는 일감이 처음이라 큰 일감에 대한 GIT commit 정리 하는 방법도 고민하고 있는데, 이에 대해서도 정리해보도록 하자.
- 신규메뉴추가 아이템 이어서 진행하기
- 맡은 솔루션의 핵심 구조 문서화 하기
- git flow 정립하고 리뷰어를 위한 Commit 정리 방법 정리하기

올해초 부터 이직에 대한 생각에 마음은 조급해지고, 하는일은 없는거 같으니, 이것저것 읽고 시작했다가 금방 손 떼는 등 방향성 없이 허우적거리고 있었다.
지금부터라도 내가 할 수 있는 것을 한 방향으로 이어갈 수 있게 노력해보자.